// **************************************************************************
// File       [ simulator.cpp ]
// Author     [ littleshamoo ]
// Synopsis   [ ]
// Date       [ 2011/09/14 created ]
// **************************************************************************

#include "simulator.h"

using namespace std;
using namespace IntfNs;
using namespace CoreNs;

// **************************************************************************
// Function   [ ppGoodSim ]
// Commentor  [ Bill ]
// Synopsis   [ usage: for each pattern generated,
//					   apply them separately and run good circuit simulation
//              in:    all the patterns generated by atpg
//              out:   void //TODO not void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppGoodSim(PatternProcessor *)
void Simulator::ppGoodSim(PatternProcessor *pcoll)
{
	for (int i = 0; i < (int)pcoll->patternVector_.size(); i += WORD_SIZE)
	{
		ppSetPattern(pcoll, i);
		goodSim();
	}
} //}}}

// **************************************************************************
// Function   [ Simulator::eventFaultSim ]
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: call faultEval function whose gate's ID in
//                     stack event and check faulty value is equal to good
//                     value or not
//                     If the values are the same, no more process is needed
//                     If the values are not the same, keep processing
//              in:    void //TODO not void
//              out:   void //TODO not void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
//{{{ void Simulator::eventFaultSim()
void Simulator::eventFaultSim()
{
	for (int i = 0; i < cir_->tlvl_; ++i)
	{
		while (!events_[i].empty())
		{
			int gid = events_[i].top(); // get gate's ID
			events_[i].pop();
			processed_[gid] = false;
			faultEval(gid);
			recover_[nrecover_] = gid; // record gate's ID
			nrecover_++;

			// check whether faulty value and good value are equal
			if (cir_->gates_[gid].fl_ == cir_->gates_[gid].gl_ && cir_->gates_[gid].fh_ == cir_->gates_[gid].gh_)
				continue;

			// if not equal and flag = false. set flag true
			for (int j = 0; j < cir_->gates_[gid].nfo_; ++j)
			{
				int foid = cir_->gates_[gid].fos_[j];
				if (processed_[foid])
					continue;
				events_[cir_->gates_[foid].lvl_].push(foid);
				processed_[foid] = true;
			}
		}
	}
} //}}}

// **************************************************************************
// Function   [ void Simulator::pfFaultSim(PatternProcessor *, FaultListExtract *) ]
// Author     [ littleshamoo ]
// Synopsis   [ usage: perform parallel fault simulation on all patterns.
//					   call pfFaultSim(FaultList &remain) for each pattern
//				in:	   a set of pattern
//				out:   void //TODO not void
//			  ]
// Date       [ ]
// **************************************************************************
void Simulator::pfFaultSim(PatternProcessor *pcoll, FaultListExtract *fListExtract)
{
	// undetected faults are remaining faults
	FaultList remain;
	for (Fault *const &pFault : fListExtract->faultsInCircuit_)
		if (pFault->faultState_ != Fault::DT && pFault->faultState_ != Fault::RE && pFault->faultyLine_ >= 0)
			remain.push_back(pFault);

	// simulate all patterns for all faults
	for (Pattern *const &pPattern : pcoll->patternVector_)
	{
		if (remain.size() == 0)
			break;

		// Assign pattern to circuit PI & PPI for further fault sim
		assignPatternToPi(pPattern);
		pfFaultSim(remain);
	}
}

// **************************************************************************
// Function   [ Simulator::pfFaultSim ]
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: set pattern. call pfFaultSim(FaultList &remain)
//                     to do faultsim for this pattern
//              in:    one pattern , FaultList contain undetected faults
//              out:   void //TODO not void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
void Simulator::pfFaultSim(const Pattern *const p, FaultList &remain)
{

	// Assign pattern to circuit PI & PPI for further fault sim
	assignPatternToPi(p);
	pfFaultSim(remain);
}

// **************************************************************************
// Function   [ Simulator::pfFaultSim ]
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: do faultsim for the fault in fault list
//              in:    FaultList ( = list<Fault *> ) contains undetected faults
//              out:   void //TODO not void
//            ]
// Date       [ CJY Ver. 1.0 started 2013/08/14 ]
// **************************************************************************
void Simulator::pfFaultSim(FaultList &remain)
{
	if (remain.size() == 0)
		return;

	// run good simulation first
	goodSimCopyToFault();

	// inject number of WORD_SIZE activated faults
	// pfReset();
	FaultListIter it = remain.begin();
	while (it != remain.end()) // do while => while by wang
	{
		// if fault is activated, inject fault
		if (pfCheckActivation(*it))
		{
			pfInject(*it, ninjected_);
			injected_[ninjected_++] = it;
		}
		++it;
		// run fault sim if enough fault or end of fault list
		if (ninjected_ == (int)WORD_SIZE || (it == remain.end() && ninjected_ > 0))
		{
			eventFaultSim();
			pfCheckDetection(remain); // drop fault here
			pfReset();
		}
	}
}

// **************************************************************************
// Function   [ Simulator::pfCheckActivation ]
// Commentor  [ CJY CBH ]
// Synopsis   [ usage: check whether the fault can be activate to the fanout of the gate
//                     ie, compare good low & high with the fault type
//              in:    address of fault to be tested
//              out:   bool //TODO what does this boolean mean
//            ]
// Date       [ CBH Ver. 1.0 started 2013/08/18 ]
// **************************************************************************
//{{{ bool Simulator::pfCheckActivation(const Fault * const)
bool Simulator::pfCheckActivation(const Fault *const f)
{
	const int &fg = f->faultyLine_ == 0 ? f->gateID_ : cir_->gates_[f->gateID_].fis_[f->faultyLine_ - 1];
	const ParaValue &gl = cir_->gates_[fg].gl_;
	const ParaValue &gh = cir_->gates_[fg].gh_;

	switch (f->faultType_)
	{
		case Fault::SA0:
			return gh != PARA_L;
			break;
		case Fault::SA1:
			return gl != PARA_L;
			break;
		case Fault::STR:
			if (cir_->nframe_ < 2)
				return false;
			return (gl & cir_->gates_[fg + cir_->ngate_].gh_) != PARA_L;
			break;
		case Fault::STF:
			if (cir_->nframe_ < 2)
				return false;
			return (gh & cir_->gates_[fg + cir_->ngate_].gl_) != PARA_L;
			break;
		default:
			break;
	}
	return false;
} //}}}

// **************************************************************************
// Function   [ simulator::pfInject ]
// Commentor  [ CJY CBH]
// Synopsis   [ usage: push faulty gate to event list
//              in:    fault, index of injected fault
//              out:   void //TODO not void
//            ]
// Date       [ CBH Ver. 1.0 started 2031/08/18 ]
// **************************************************************************
//{{{ void Simulator::pfInject(const Fault * const , const size_t &)
void Simulator::pfInject(const Fault *const f, const size_t &i)
{
	int fg = f->gateID_;
	switch (f->faultType_)
	{
		case Fault::SA0:
			setBitValue(faultInjectL_[fg][f->faultyLine_], i, H);
			break;
		case Fault::SA1:
			setBitValue(faultInjectH_[fg][f->faultyLine_], i, H);
			break;
		case Fault::STR:
			fg += cir_->ngate_;
			setBitValue(faultInjectL_[fg][f->faultyLine_], i, H);
			break;
		case Fault::STF:
			fg += cir_->ngate_;
			setBitValue(faultInjectH_[fg][f->faultyLine_], i, H);
			break;
		default:
			break;
	}

	// put gate into event list
	if (!processed_[fg])
	{
		events_[cir_->gates_[fg].lvl_].push(fg);
		processed_[fg] = true;
	}
} //}}}

// **************************************************************************
// Function   [ simulator::pfCheckDetection ]
// Commentor  [ CJY CBH]
// Synopsis   [ usage: compare the good sim and fault sim result
//					   and check whether the injected fault can be detected by the  pattern
//              in:    the list of undetected fault
//              out:   void //TODO not void
//            ]
// Date       [ CBH Ver. 1.0 started 2031/08/18 ]
// **************************************************************************
void Simulator::pfCheckDetection(FaultList &remain)
{
	ParaValue detected = PARA_L;
	int start = cir_->tgate_ - cir_->npo_ - cir_->nppi_;
	for (int i = start; i < cir_->tgate_; ++i)
		detected |= ((cir_->gates_[i].gl_ & cir_->gates_[i].fh_) | (cir_->gates_[i].gh_ & cir_->gates_[i].fl_));

	// fault drop
	for (int i = 0; i < ninjected_; ++i)
	{
		if (getBitValue(detected, (size_t)i) == L)
			continue;
		(*injected_[i])->detection_++;
		if ((*injected_[i])->detection_ >= ndet_)
		{
			(*injected_[i])->faultState_ = Fault::DT;
			remain.erase(injected_[i]);
		}
	}
}

// **************************************************************************
// Function   [ void Simulator::ppFaultSim(PatternSet *, FaultListExtract *) ]
// Author     [ littleshamoo ]
// Synopsis   [ usage: perform parallel pattern simulation on all faults.
//				in:    a set of pattern, FaultListExtract
//				out:   void
//			  ]
// Date       [ ]
// **************************************************************************
void Simulator::ppFaultSim(PatternProcessor *pcoll, FaultListExtract *fListExtract)
{
	// undetected faults are remaining faults
	FaultList remain;
	FaultListIter it = fListExtract->faultsInCircuit_.begin();
	for (; it != fListExtract->faultsInCircuit_.end(); ++it)
		if ((*it)->faultState_ != Fault::DT && (*it)->faultState_ != Fault::RE && (*it)->faultyLine_ >= 0)
			remain.push_back(*it);

	// simulate all patterns for all faults
	for (int i = 0; i < (int)pcoll->patternVector_.size(); i += WORD_SIZE)
	{
		ppSetPattern(pcoll, i);
		ppFaultSim(remain);
	}
} //}}}

// **************************************************************************
// Function   [ Simulator::ppFaultSim ]
// Commentor  [ Bill ]
// Synopsis   [ usage: simulate all undetected faults
//              in:    a set of undetected fault
//              out:   void //TODO not void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppFaultSim(FaultList &)
void Simulator::ppFaultSim(FaultList &remain)
{
	if (remain.size() == 0)
		return;

	// run good simulation first
	goodSimCopyToFault();

	FaultListIter it = remain.begin();
	do
	{
		if (ppCheckActivation((*it)))
		{
			ppInject((*it));
			eventFaultSim();
			ppCheckDetection((*it));
			ppReset();
		}
		if ((*it)->faultState_ == Fault::DT)
			it = remain.erase(it);
		else
			it++;
	} while (it != remain.end());
} //}}}

// **************************************************************************
// Function   [ ppCheckActivation ]
// Commentor  [ Bill ]
// Synopsis   [ usage: check whether the fault can be activate to the fanout of the gate
//              in:    fault to be tested
//              out:   bool // what does this boolean mean
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ bool Simulator::ppCheckActivation(const Fault * const)
bool Simulator::ppCheckActivation(const Fault *const f)
{
	const int &fg = f->faultyLine_ == 0 ? f->gateID_ : /// if output fault,fg=ID of the faulty gate,else if input fault,fg=ID of the faulty gate's fanin array
											cir_->gates_[f->gateID_].fis_[f->faultyLine_ - 1];
	const ParaValue &gl = cir_->gates_[fg].gl_;
	const ParaValue &gh = cir_->gates_[fg].gh_;

	switch (f->faultType_)
	{
		case Fault::SA0:
			activated_ = gh;
			return activated_ != PARA_L;
			break;
		case Fault::SA1:
			activated_ = gl;
			return activated_ != PARA_L;
			break;
		case Fault::STR:
			if (cir_->nframe_ < 2)
				return false;
			activated_ = (gl & cir_->gates_[fg + cir_->ngate_].gh_);
			return activated_ != PARA_L;
			break;
		case Fault::STF:
			if (cir_->nframe_ < 2)
				return false;
			activated_ = (gh & cir_->gates_[fg + cir_->ngate_].gl_);
			return activated_ != PARA_L;
			break;
		default:
			break;
	}
	return false;
} //}}}

// **************************************************************************
// Function   [ ppInject ]
// Commentor  [ Bill ]
// Synopsis   [ usage: inject fault
//              in:    a fault to be injected
//              out:   void //TODO not void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppInject(const Fault * const)
void Simulator::ppInject(const Fault *const f)
{
	int fg = f->gateID_;
	switch (f->faultType_)
	{
		case Fault::SA0:
			faultInjectL_[fg][f->faultyLine_] = PARA_H;
			break;
		case Fault::SA1:
			faultInjectH_[fg][f->faultyLine_] = PARA_H;
			break;
		case Fault::STR:
			fg += cir_->ngate_;
			faultInjectL_[fg][f->faultyLine_] = PARA_H;
			break;
		case Fault::STF:
			fg += cir_->ngate_;
			faultInjectH_[fg][f->faultyLine_] = PARA_H;
			break;
		default:
			break;
	}

	// put gate into event list
	if (!processed_[fg])
	{
		events_[cir_->gates_[fg].lvl_].push(fg);
		processed_[fg] = true;
	}
} //}}}

// **************************************************************************
// Function   [ ppCheckDetection ]
// Commentor  [ Bill ]
// Synopsis   [ usage: compare the good sim and fault sim result
//					   and check whether the injected fault can be detected by the  pattern
//              in:    a fault which is injected into the circuit
//              out:   void //not void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppCheckDetection(Fault * const)
void Simulator::ppCheckDetection(Fault *const f)
{
	ParaValue detected = PARA_L;
	int start = cir_->tgate_ - cir_->npo_ - cir_->nppi_;
	for (int i = start; i < cir_->tgate_; ++i)
	{
		// TO-DO homework 02
		detected |= ((cir_->gates_[i].gl_ & cir_->gates_[i].fh_) | (cir_->gates_[i].gh_ & cir_->gates_[i].fl_));
		// end of TO-DO
	}
	detected &= activated_;

	// fault drop
	for (size_t i = 0; i < WORD_SIZE; ++i)
	{
		if (getBitValue(detected, i) == L)
			continue;
		f->detection_++;
		if (f->detection_ >= ndet_)
		{
			f->faultState_ = Fault::DT;
			break;
		}
	}
} //}}}

// **************************************************************************
// Function   [ ppSetPattern ]
// Commentor  [ Bill ]
// Synopsis   [ usage: apply pattern
//              in:    the total pattern set,
//					   and an integer to represent the starting pattern of current fsim
//              out:   void // not void
//            ]
// Date       [ Bill Ver. 1.0 started 20130811 ]
// **************************************************************************
//{{{ void Simulator::ppSetPattern(PatternProcessor *, const int &)
void Simulator::ppSetPattern(PatternProcessor *pcoll, const int &i)
{ // TODO LOS not yet supported
	// reset PI and PPI values to unknowns
	for (int j = 0; j < cir_->npi_ + cir_->nppi_; ++j)
	{
		for (int k = 0; k < cir_->nframe_; ++k)
		{
			cir_->gates_[j + k * cir_->ngate_].gl_ = PARA_L;
			cir_->gates_[j + k * cir_->ngate_].gh_ = PARA_L;
		}
	}

	// assign up to WORD_SIZE number of pattern values
	int endpat = (int)pcoll->patternVector_.size();
	if (i + (int)WORD_SIZE <= (int)pcoll->patternVector_.size())
		endpat = i + WORD_SIZE;
	for (int j = i; j < endpat; ++j)
	{
		// assign PI
		if (!pcoll->patternVector_[j]->pPI1_.empty())
		{
			for (int k = 0; k < pcoll->numPI_; ++k)
			{
				if (pcoll->patternVector_[j]->pPI1_[k] == L)
					setBitValue(cir_->gates_[k].gl_, j - i, H);
				else if (pcoll->patternVector_[j]->pPI1_[k] == H)
					setBitValue(cir_->gates_[k].gh_, j - i, H);
			}
		}
		// if (pcoll->patternVector_[j]->pPI2_ && cir_->nframe_ > 1)
		if (!pcoll->patternVector_[j]->pPI2_.empty() && cir_->nframe_ > 1)
		{
			for (int k = 0; k < pcoll->numPI_; ++k)
			{
				int index = k + cir_->ngate_;
				if (pcoll->patternVector_[j]->pPI2_[k] == L)
					setBitValue(cir_->gates_[index].gl_, j - i, H);
				else if (pcoll->patternVector_[j]->pPI2_[k] == H)
					setBitValue(cir_->gates_[index].gh_, j - i, H);
			}
		}
		// assign PPI
		if (!pcoll->patternVector_[j]->pPPI_.empty())
		{
			for (int k = 0; k < pcoll->numPPI_; ++k)
			{
				int index = k + cir_->npi_;
				if (pcoll->patternVector_[j]->pPPI_[k] == L)
					setBitValue(cir_->gates_[index].gl_, j - i, H);
				else if (pcoll->patternVector_[j]->pPPI_[k] == H)
					setBitValue(cir_->gates_[index].gh_, j - i, H);
			}
		}

		// if (pcoll->patternVector_[j]->pSI_ && cir_->nframe_ > 1 && cir_->connType_ == Circuit::SHIFT)
		if (!pcoll->patternVector_[j]->pSI_.empty() && cir_->nframe_ > 1 && cir_->connType_ == Circuit::SHIFT)
		{
			int index = cir_->ngate_ + cir_->npi_;
			if (pcoll->patternVector_[j]->pSI_[0] == L)
				setBitValue(cir_->gates_[index].gl_, j - i, H);
			else if (pcoll->patternVector_[j]->pSI_[0] == H)
				setBitValue(cir_->gates_[index].gh_, j - i, H);
		}
	}
} //}}}
